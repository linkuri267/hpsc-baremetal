#define DEBUG 1

#include <stdbool.h>
#include <stdint.h>

#include "console.h"
#include "object.h"
#include "mem.h"
#include "bit.h"
#include "regops.h"
#include "sleep.h"

#include "rio-pkt.h"
#include "rio-dev.h"

#include "rio-ep.h"

#define RIO_MAX_PAYLOAD_SIZE 256 /* TODO: check */
#define MAX_MSGSEG_XMBOXMENTS 16 /* Spec 2.3.1 */
#define MAX_MSGSEG_XMBOX_SIZE 256 /* keep in sync with msg_seg_sizes list in rio.c */
#define MAX_MSG_DESC_SIZE 32 /* keep in sync with msg_desc_sizes in rio.c */

#define RIO_NUM_OUT_REGIONS         64 /* User Guide Table 119 */
#define RIO_NUM_IN_ADDR_SPACES      64 /* User Guide Table 120 */

#define RIO_MAX_PKT_SIZE 64 /* TODO */
#define MAX_MSG_SIZE 256 /* TODO */

#define NUM_MBOXES 4
#define NUM_LETTERS 4

#define NUM_MSG_RX_CHAINS 2
#define MSG_CHAIN_BUF_SIZE ((MAX_MSG_DESC_SIZE + MAX_MSGSEG_XMBOX_SIZE) * MAX_MSGSEG_XMBOXMENTS)

#define RX_MSG_FIFO_SIZE 4

/* Must not overlap with TIDs generated by HW, fixed by HW impl */
#define TID_SW 0x0

#define POLL_INTERVAL_MS 1000

struct rx_msg {
    uint8_t payload[MAX_MSG_SIZE];
    unsigned len; /* bytes */
    uint32_t segments; /* assert(width >= MAX_MSGSEG_XMBOXMENTS) */
    rio_devid_t src_id;
    uint64_t rcv_time;
};

struct rx_msg_fifo {
    unsigned head;
    unsigned tail;
    struct rx_msg q[RX_MSG_FIFO_SIZE];
};

struct rio_ep {
    const char *name;
    uintptr_t base;
    rio_bus_addr_t out_as_base;
    unsigned out_as_width;
    enum rio_transport_type ttype;
    unsigned addr_width;

    rio_bus_addr_t buf_mem_ep;
    uint8_t *buf_mem_cpu;
    unsigned buf_mem_size;

    uint8_t (*msg_tx_desc_buf);
    unsigned msg_tx_desc_buf_size;

    uint8_t (*msg_rx_desc_buf)[MSG_CHAIN_BUF_SIZE];
    unsigned msg_rx_desc_buf_size;

    rio_devid_t devid;
    uint8_t *msg_rx_desc_addr;
    unsigned rx_chain;

    unsigned mapped_out_regions;
    unsigned mapped_in_addr_spaces;

    uint8_t pkt_buf[RIO_MAX_PKT_SIZE];


    /* A FIFO for received messages, one FIFO per mbox, letter endpoint.
       Only one in-flight (i.e. incomplete) message per mbox/letter is supported.
       But, we support a FIFO between driver and consumer, where *completed*
       messages are queued. The in-flight message is assembled in the "current"
       slot in this FIFO. */
    struct rx_msg_fifo rx_msgs[NUM_MBOXES][NUM_LETTERS];

    struct RioPkt in_pkt;
    struct RioPkt out_pkt;
};

enum sp_tx_fifo_state {
    SP_TX_FIFO_STATE_IDLE   = 0x0,
    SP_TX_FIFO_STATE_ARMED  = 0x1,
    SP_TX_FIFO_STATE_ACTIVE = 0x2,
};

enum sp_rx_fifo_state {
    SP_RX_FIFO_STATE_IDLE   = 0x0,
    SP_RX_FIFO_STATE_ACTIVE = 0x1,
};

enum access_type {
    ACCESS_READ,
    ACCESS_WRITE,
};

/* Implementation-specific registers (shouldn't be exposed outside of the
 * driver). */

/* See comment in rio.h for explanation for the pattern in the index expr.. */

REG32(IR_SP_TX_CTRL, 0x107000)
    FIELD(IR_SP_TX_CTRL, OCTETS_TO_SEND,        32 -  0 - 16, 16)
REG32(IR_SP_TX_STAT, 0x107004)
    FIELD(IR_SP_TX_STAT, OCTETS_REMAINING,      32 -  0 - 16, 16)
    FIELD(IR_SP_TX_STAT, BUFFERS_FILLED,        32 - 16 -  4,  4)
    FIELD(IR_SP_TX_STAT, FULL,                  32 - 27 -  1,  1)
    FIELD(IR_SP_TX_STAT, TX_FIFO_STATE,         32 - 28 -  4,  4)
REG32(IR_SP_TX_DATA, 0x107008)
REG32(IR_SP_RX_CTRL, 0x10700c)
    FIELD(IR_SP_RX_CTRL, OVERFLOW_MODE_NO_DISCARD, 32 - 31 - 1,  1)
REG32(IR_SP_RX_STAT, 0x107010)
    FIELD(IR_SP_RX_STAT, OCTETS_REMAINING,      32 -  0 - 16, 16)
    FIELD(IR_SP_RX_STAT, BUFFERS_FILLED,        32 - 16 -  4,  4)
    FIELD(IR_SP_RX_STAT, FULL,                  32 - 27 -  1,  1)
    FIELD(IR_SP_RX_STAT, RX_FIFO_STATE,         32 - 28 -  4,  4)
REG32(IR_SP_RX_DATA, 0x107014)

REG32(IR_MSG_CTRL, 0x107100)
REG32(IR_MSG_INIT_PS_STAT, 0x107110)
    FIELD(IR_MSG_INIT_PS_STAT, IDLE,            32 -  0 -  1, 1)
    FIELD(IR_MSG_INIT_PS_STAT, MAX_DESCRIPTORS, 32 -  1 -  3, 3)
    FIELD(IR_MSG_INIT_PS_STAT, DESCRIPTORS,     32 -  4 -  3, 3)
REG32(IR_MSG_INIT_PS_DESCR_FIFO_L, 0x107114)
REG32(IR_MSG_INIT_PS_DESCR_FIFO_H, 0x107118)
REG32(IR_MSG_INIT_DS_STAT, 0x107130)
    FIELD(IR_MSG_INIT_DS_STAT, IDLE,            32 -  0 -  1, 1)
    FIELD(IR_MSG_INIT_DS_STAT, MAX_DESCRIPTORS, 32 -  1 -  3, 3)
    FIELD(IR_MSG_INIT_DS_STAT, DESCRIPTORS,     32 -  4  - 3, 3)
REG32(IR_MSG_INIT_DS_DESCR_FIFO_L, 0x107134)
REG32(IR_MSG_INIT_DS_DESCR_FIFO_H, 0x107138)
REG32(IR_MSG_TRGT_STAT, 0x107150)
    FIELD(IR_MSG_TRGT_STAT, IDLE,               32 -  0 -  1, 1)
    FIELD(IR_MSG_TRGT_STAT, MAX_DESCRIPTORS,    32 -  1 -  3, 3)
    FIELD(IR_MSG_TRGT_STAT, DESCRIPTORS,        32 -  4 -  3, 3)
REG32(IR_MSG_TRGT_DESCR_FIFO_L, 0x107154)
REG32(IR_MSG_TRGT_DESCR_FIFO_H, 0x107158)

REG32(IR_OMAP_CTRL, 0x200000)
    FIELD(IR_OMAP_CTRL, SUBREGIONS,             32 -  1 -  3,  3)
REG32(IR_OME_0_CTRL, 0x200400)
    FIELD(IR_OME_0_CTRL, WRITE_TYPE,            32 -  0 -  2,  2)
    FIELD(IR_OME_0_CTRL, PRIO,                  32 -  2 -  2,  2)
    FIELD(IR_OME_0_CTRL, TTYPE,                 32 -  4 -  2,  2)
    FIELD(IR_OME_0_CTRL, XAMSBS,                32 -  6 -  2,  2)
    FIELD(IR_OME_0_CTRL, CRF,                   32 -  8 -  1,  1)
    FIELD(IR_OME_0_CTRL, ADDR_SIZE,             32 -  9 -  2,  2)
/* There are IR_OME_x_* for x from 0 to 63, they are implied by the addresses
 * of following registers. To refer to these registers use offset from 0:
 * (IR_OME_0_* + region) and to access the fields use the macros for 0. */
REG32(IR_OME_0_DESTID, 0x200500)
REG32(IR_OME_0_ADDR_H, 0x200600)
REG32(IR_OME_0_ADDR_L, 0x200700)

REG32(IR_IMAP_CTRL, 0x300000)
    FIELD(IR_IMAP_CTRL, SUBREGIONS,             32 -  1 -  3,  3)
REG32(IR_IME_0_CTRL, 0x300400)
    FIELD(IR_IME_0_CTRL, ADDR_SIZE,             32 -  0 -  2,  2)
REG32(IR_IME_0_SRCID, 0x300500)
REG32(IR_IME_0_SRCIDM, 0x300600)
REG32(IR_IME_0_ADDR_H, 0x300700)
REG32(IR_IME_0_ADDR_L, 0x300800)

/* Mesage descriptor fields: see Chapter 7.2 in User Guide.
 * Convention for bit position index: 64 - start - width,
 * so that 'start' value matches the User Guide verbatim.
 */
FIELD(MSG_DESC, PRIO,           64 -  0 -  4,  4)
FIELD(MSG_DESC, INTERRUPT,      64 -  4 -  1,  1)
FIELD(MSG_DESC, FREE,           64 -  5 -  1,  1)
FIELD(MSG_DESC, TTYPE,          64 -  6 -  2,  2)
FIELD(MSG_DESC, SRC_ID,         64 -  8 - 32, 32) /* overlaps */
FIELD(MSG_DESC, DEST_ID,        64 -  8 - 32, 32) /* overlaps */
FIELD(MSG_DESC, MSG_LEN,        64 - 40 -  4,  4)
FIELD(MSG_DESC, SEG_SIZE,       64 - 44 -  4,  4)
FIELD(MSG_DESC, LETTER,         64 - 48 -  2,  2)
FIELD(MSG_DESC, MBOX,           64 - 50 -  2,  2)
FIELD(MSG_DESC, MSGSEG_XMBOX,   64 - 52 -  4,  4)

typedef enum MsgDescType {
    MSG_DESC_INITIATOR_PS,
    MSG_DESC_INITIATOR_DS,
    MSG_DESC_TARGET,
} MsgDescType;

typedef struct MsgDesc {
    MsgDescType type;
    uint8_t prio;
    bool interrupt;
    bool free;
    enum rio_transport_type ttype;
    union {
        uint32_t dest_id;
        uint32_t src_id;
    } dev_id;
    uint8_t msg_len;
    uint8_t seg_size;
    uint8_t mbox;
    uint8_t letter;
    uint8_t msg_seg;
    uint8_t *payload_ptr;
    uint8_t *next_desc_addr; /* packed, so not a MsgDesc* */
    union {
        uint64_t rcv_time;
    } timestamp;
} MsgDesc;

#define MAX_RIO_ENDPOINTS 2

static struct rio_ep rio_eps[MAX_RIO_ENDPOINTS] = {0};

/* User Guide Table 120 */
enum MapWriteType {
   MAP_DISABLED = 0b00,
   MAP_NWRITE   = 0b01,
   MAP_NWRITE_R = 0b10,
   MAP_SWRITE   = 0b11,
};

/* User Guide Table 120: number of bits -> choice field value */
static uint8_t rio_addr_width_to_field(enum rio_addr_width size)
{
    switch (size) {
        case RIO_ADDR_WIDTH_34_BIT: return 0b00;
        case RIO_ADDR_WIDTH_50_BIT: return 0b01;
        case RIO_ADDR_WIDTH_66_BIT: return 0b10;
    }
    ASSERT(!"invalid value in rio_addr_width enum");
    return 0; /* unreachable */
}

static inline unsigned div_ceil(unsigned x, unsigned y)
{
    return x / y + (x % y ? 1 : 0);
}

/* To support buffers in hi memory, CPU accesses via a window in 32-bit
   address space (window is provided to the driver by the consumer). */
static inline rio_bus_addr_t cpu_to_ep_addr(struct rio_ep *ep, uint8_t *cpu_addr)
{
    if (!cpu_addr)
        return 0;
    ASSERT(ep->buf_mem_cpu <= cpu_addr && cpu_addr < ep->buf_mem_cpu + ep->buf_mem_size);
    rio_bus_addr_t ep_addr = ep->buf_mem_ep + (cpu_addr - ep->buf_mem_cpu);
    ASSERT(ep->buf_mem_ep <= ep_addr && ep_addr < ep->buf_mem_ep + ep->buf_mem_size);
    return ep_addr;
}
static inline uint8_t *ep_to_cpu_addr(struct rio_ep *ep, rio_bus_addr_t ep_addr)
{
    if (ep_addr == 0)
        return NULL;
    ASSERT(ep->buf_mem_ep <= ep_addr && ep_addr < ep->buf_mem_ep + ep->buf_mem_size);
    uint8_t *cpu_addr = ep->buf_mem_cpu + (ep_addr - ep->buf_mem_ep);
    ASSERT(ep->buf_mem_cpu <= cpu_addr && cpu_addr < ep->buf_mem_cpu + ep->buf_mem_size);
    return cpu_addr;
}

static void print_payload(struct RioPkt *pkt)
{
    printf("\tpayload [%u dwords]:", pkt->payload_len);
    for (int dw = 0; dw < pkt->payload_len; ++dw) {
        uint64_t val = pkt->payload[dw];
        printf(" %08x%08x", (uint32_t)(val >> 32),
                            (uint32_t)(val & 0xffffffff));
    }
    printf("\r\n");
}

void rio_print_pkt(struct RioPkt *pkt)
{
    printf("RIO PKT: ftype %u from devid %x -> to devid %x\r\n",
           pkt->ftype, pkt->src_id, pkt->dest_id);

    switch (pkt->ftype) {
        case RIO_FTYPE_MAINT:
        case RIO_FTYPE_READ:
        case RIO_FTYPE_WRITE:
            printf("\ttransaction %x src_tid %x target_tid %x hops %u\r\n"
                    "\tstatus %x\r\n"
                    "\tdw_addr 0x%08x%08x dw_offset %u rdwr_bytes %u\r\n",
                    pkt->transaction, pkt->src_tid, pkt->target_tid,
                    pkt->hop_count, pkt->status,
                    (uint32_t)(pkt->dw_addr >> 32),
                    (uint32_t)(pkt->dw_addr & 0xffffffff),
                    pkt->dw_offset, pkt->rdwr_bytes);
            print_payload(pkt);
            break;
        case RIO_FTYPE_MSG:
            printf("\tmsg_len %u msg_seg %u seg size %u\r\n"
                    "\tmbox %u letter %u\r\n",
                    pkt->msg_len, pkt->msg_seg, pkt->seg_size,
                    pkt->mbox, pkt->letter);
            print_payload(pkt);
            break;
        case RIO_FTYPE_DOORBELL:
            printf("\tsrc_tid 0x%x info 0x%x\r\n",
                    pkt->src_tid, pkt->info);
            break;
        case RIO_FTYPE_RESP:
            printf("\ttransaction 0x%x\r\n", pkt->transaction);
            switch (pkt->transaction) {
                case RIO_TRANS_RESP_MSG:
                    printf("\tmbox %u letter %u msg_seg %u\r\n",
                            pkt->mbox, pkt->letter, pkt->msg_seg);
                    break;
                case RIO_TRANS_RESP_WITHOUT_PAYLOAD:
                    printf("\ttarget_tid 0x%x\r\n", pkt->target_tid);
                    break;
                case RIO_TRANS_RESP_WITH_PAYLOAD:
                    printf("\ttarget_tid 0x%x\r\n", pkt->target_tid);
                    print_payload(pkt);
                    break;
                default:
                    ASSERT(!"resp trans type not implemented");
            }
            break;
        default:
            ASSERT(!"pkt type not implemented");
    }
}

/* The desc is in memory, but we use register API to handle endianness. */
static uint64_t msg_desc_read_dw(uint8_t *desc, unsigned len, unsigned *pos)
{
    ASSERT(*pos + sizeof(uint64_t) <= len);
    uint64_t val = RIO_REG_READ64(desc + *pos);
    *pos += sizeof(uint64_t);
    printf("msg desc %p[%u] -> 0x%08x%08x\r\n", desc, *pos,
           (uint32_t)(val >> 32), (uint32_t)val);
    return val;
}
static void msg_desc_write_dw(uint8_t *desc, unsigned size, unsigned *pos,
                              uint64_t val)
{
    printf("msg desc %p[%u] <- 0x%08x%08x\r\n", desc, *pos,
           (uint32_t)(val >> 32), (uint32_t)val);
    ASSERT(*pos + sizeof(uint64_t) <= size);
    RIO_REG_WRITE64(desc + *pos, val);
    *pos += sizeof(uint64_t);
}

static unsigned pack_msg_desc(struct rio_ep *ep, uint8_t *buf, unsigned size,
                              MsgDesc *desc)
{
    unsigned pos = 0;
    uint64_t hdr = 0;

    hdr = FIELD_DP64(hdr, MSG_DESC, PRIO, desc->prio);
    hdr = FIELD_DP64(hdr, MSG_DESC, INTERRUPT, desc->interrupt);
    hdr = FIELD_DP64(hdr, MSG_DESC, FREE, desc->free);
    hdr = FIELD_DP64(hdr, MSG_DESC, TTYPE, desc->ttype);
    hdr = FIELD_DP64(hdr, MSG_DESC, DEST_ID, desc->dev_id.dest_id);
    hdr = FIELD_DP64(hdr, MSG_DESC, MSG_LEN, desc->msg_len - 1); /* 0->1 */

    uint8_t seg_size_field = msg_seg_size_field(desc->seg_size);
    ASSERT(seg_size_field != MSG_SEG_FIELD_INVALID);
    hdr = FIELD_DP64(hdr, MSG_DESC, SEG_SIZE, seg_size_field);

    hdr = FIELD_DP64(hdr, MSG_DESC, MBOX, desc->mbox & 0b11);
    hdr = FIELD_DP64(hdr, MSG_DESC, LETTER, desc->letter);
    if (desc->msg_len > 0) {
        hdr = FIELD_DP64(hdr, MSG_DESC, MSGSEG_XMBOX, desc->msg_seg);
        ASSERT(desc->mbox >> 2 == 0);
    } else {
        hdr = FIELD_DP64(hdr, MSG_DESC, MSGSEG_XMBOX,
                         (desc->mbox >> 2) & 0b1111);
        ASSERT(desc->mbox >> (2 + 4) == 0);
    }
    msg_desc_write_dw(buf, size, &pos, hdr);
    msg_desc_write_dw(buf, size, &pos, cpu_to_ep_addr(ep, desc->payload_ptr));
    msg_desc_write_dw(buf, size, &pos, cpu_to_ep_addr(ep, desc->next_desc_addr));
    return pos;
}

/* This function is verbatime from Qemu model */
static int unpack_msg_desc(struct rio_ep *ep, MsgDesc *desc,
                           uint8_t *buf, unsigned len, MsgDescType type)
{
    unsigned pos = 0;
    uint64_t hdr;

    desc->type = type;

    hdr = msg_desc_read_dw(buf, len, &pos);

    desc->prio = FIELD_EX64(hdr, MSG_DESC, PRIO);
    desc->interrupt = FIELD_EX64(hdr, MSG_DESC, INTERRUPT);
    desc->free = FIELD_EX64(hdr, MSG_DESC, FREE);
    desc->ttype = FIELD_EX64(hdr, MSG_DESC, TTYPE);
    if (type == MSG_DESC_TARGET) {
        desc->dev_id.src_id = FIELD_EX64(hdr, MSG_DESC, SRC_ID);
    } else {
        desc->dev_id.dest_id = FIELD_EX64(hdr, MSG_DESC, DEST_ID);
    }
    desc->msg_len = FIELD_EX64(hdr, MSG_DESC, MSG_LEN) + 1; /* 0->1 */

    uint8_t seg_size = FIELD_EX64(hdr, MSG_DESC, SEG_SIZE);
    if (msg_seg_size(seg_size) == MSG_SEG_SIZE_INVALID) {
        printf("RIO: NOTICE: invalid segment size in msg descriptor: %x\n",
                 seg_size);
        return 1;
    }
    desc->seg_size = msg_seg_size(seg_size);

    desc->mbox = FIELD_EX64(hdr, MSG_DESC, MBOX);
    desc->letter = FIELD_EX64(hdr, MSG_DESC, LETTER);
    if (desc->msg_len > 1) {
        desc->msg_seg = FIELD_EX64(hdr, MSG_DESC, MSGSEG_XMBOX);
        if (desc->msg_seg >= desc->msg_len) {
            printf("RIO: NOTICE: invalid msg segment index in msg descriptor: "
                     "%u (>= msg_len = %u)\n",
                     desc->msg_seg, desc->msg_len);
            return 2;
        }
    } else {
        desc->msg_seg = 0;
        desc->mbox |= (FIELD_EX64(hdr, MSG_DESC, MSGSEG_XMBOX) << 2);
    }

    desc->payload_ptr = ep_to_cpu_addr(ep, msg_desc_read_dw(buf, len, &pos));
    desc->next_desc_addr = ep_to_cpu_addr(ep, msg_desc_read_dw(buf, len, &pos));

    uint64_t timestamp = msg_desc_read_dw(buf, len, &pos);
    switch (type) {
        case MSG_DESC_TARGET:
            desc->timestamp.rcv_time = timestamp;
            break;
        default:
            /* no timestamp for other types */
            break;
    }
    return 0;
}

static void print_msg_desc(MsgDesc *desc)
{
    uint64_t timestamp;
    switch (desc->type) {
        case MSG_DESC_INITIATOR_PS: timestamp = 0; break;
        case MSG_DESC_TARGET: timestamp = desc->timestamp.rcv_time; break;
        default: ASSERT(!"invalid msg descriptor type");
    }
    uint64_t *payload = (uint64_t *)&desc->payload_ptr[0];
    printf("msg desc: next %p type %u\r\n"
           "\tinterrupt %u free %u\r\n"
           "\tprio %u ttype %u\r\n"
           "\tsrc/dest id 0x%x\r\n"
           "\tmsg_len %u seg_size %u seg %u\r\n"
           "\tmbox %u letter %u"
           "\ttimestamp %08x%08x\r\n"
           "\tpayload %p: %08x%08x ...\r\n",
           desc->next_desc_addr, desc->type,
           desc->interrupt, desc->free,
           desc->prio, desc->ttype,
           desc->dev_id.dest_id,
           desc->msg_len, desc->seg_size, desc->msg_seg,
           desc->mbox, desc->letter,
           (uint32_t)(timestamp >> 32),
           (uint32_t)(timestamp & 0xffffffff),
           desc->payload_ptr,
           (uint32_t)(payload[0] >> 32),
           (uint32_t)(payload[0] & 0xffffffff));
}

static inline void init_rx_msg(struct rx_msg *msg)
{
    msg->segments = ~0;
    msg->len = 0;
    bzero(msg->payload, sizeof(msg->payload));
}

static unsigned init_rx_chain(struct rio_ep *ep, uint8_t *buf, int size)
{
    uint8_t *desc = buf;
    unsigned num_desc = 0;

    bzero(buf, size);

    while (desc + MAX_MSG_DESC_SIZE + MAX_MSGSEG_XMBOX_SIZE <= buf + size) {
        unsigned pos = 0;
        uint64_t hdr = 0;
        hdr = FIELD_DP64(hdr, MSG_DESC, INTERRUPT, 0);
        hdr = FIELD_DP64(hdr, MSG_DESC, FREE, 0);
        msg_desc_write_dw(desc, size, &pos, hdr);

        uint8_t *payload_addr_cpu = desc + MAX_MSG_DESC_SIZE;
        ASSERT(ep->buf_mem_cpu <= payload_addr_cpu &&
               payload_addr_cpu < ep->buf_mem_cpu + ep->buf_mem_size - MAX_MSGSEG_XMBOX_SIZE);

        rio_bus_addr_t payload_addr_ep = cpu_to_ep_addr(ep, payload_addr_cpu);
        ASSERT(ep->buf_mem_ep <= payload_addr_ep &&
               payload_addr_ep < ep->buf_mem_ep + ep->buf_mem_size - MAX_MSGSEG_XMBOX_SIZE);

        msg_desc_write_dw(desc, size, &pos, payload_addr_ep);

        desc += MAX_MSG_DESC_SIZE + MAX_MSGSEG_XMBOX_SIZE;

        uint8_t *next_desc_addr_cpu = desc;
        ASSERT(ep->buf_mem_cpu <= next_desc_addr_cpu &&
               next_desc_addr_cpu < ep->buf_mem_cpu + ep->buf_mem_size - MAX_MSG_DESC_SIZE);

        rio_bus_addr_t next_desc_addr_ep = cpu_to_ep_addr(ep, next_desc_addr_cpu);
        ASSERT(ep->buf_mem_ep <= next_desc_addr_ep &&
               next_desc_addr_ep < ep->buf_mem_ep + ep->buf_mem_size - MAX_MSG_DESC_SIZE);

        msg_desc_write_dw(desc, size, &pos, next_desc_addr_ep);
        msg_desc_write_dw(desc, size, &pos, 0); /* timestamp */

        ++num_desc;
    }
    return num_desc;
}

static void reserve_rx_chain(struct rio_ep *ep, uint8_t *desc, unsigned size)
{
    uint8_t *desc_addr = desc, *payload_addr;

    while (desc_addr) {
        unsigned rd_pos = 0, wr_pos = 0;

        /* Mark descriptor as used (not free) */
        uint64_t hdr = msg_desc_read_dw(desc_addr, size, &rd_pos);
        hdr = FIELD_DP64(hdr, MSG_DESC, FREE, 0);
        msg_desc_write_dw(desc_addr, size, &wr_pos, hdr);

        /* Do some consistency checks, while walking the chain */
        uint8_t interrupt = FIELD_EX64(hdr, MSG_DESC, INTERRUPT);
        ASSERT(interrupt == 0);

        desc_addr = ep_to_cpu_addr(ep, msg_desc_read_dw(desc_addr, size, &rd_pos));
        ASSERT(desc_addr <= desc + size);

        payload_addr =
            ep_to_cpu_addr(ep, msg_desc_read_dw(desc_addr, size, &rd_pos));
        ASSERT(payload_addr <= desc + size);
    }
}

static void enqueue_rx_chain(struct rio_ep *ep, uint8_t *head_desc)
{
    rio_bus_addr_t head_desc_ep = cpu_to_ep_addr(ep, head_desc);

    ASSERT(ep->buf_mem_cpu <= head_desc &&
           head_desc < ep->buf_mem_cpu + ep->buf_mem_size - MAX_MSG_DESC_SIZE);
    ASSERT(ep->buf_mem_ep <= head_desc_ep &&
           head_desc_ep < ep->buf_mem_ep + ep->buf_mem_size - MAX_MSG_DESC_SIZE);

    RIO_REGB_WRITE32(ep->base, IR_MSG_TRGT_DESCR_FIFO_H,
                 (uint32_t)((uint64_t)head_desc_ep >> 32));
    RIO_REGB_WRITE32(ep->base, IR_MSG_TRGT_DESCR_FIFO_L,
                 (uint32_t)((uint64_t)head_desc_ep & 0xffffffff));
}

static struct rx_msg *rx_msg_peek(struct rx_msg_fifo *f)
{
    if (f->head == f->tail)
        return NULL; /* empty */
    return &f->q[f->head];
}

static struct rx_msg *rx_msg_alloc(struct rx_msg_fifo *f)
{
    struct rx_msg *m;
    unsigned next_tail = (f->tail + 1) % RX_MSG_FIFO_SIZE;
    if (next_tail == f->head)
        return NULL; /* full */
    m = &f->q[f->tail];
    f->tail = next_tail;
    init_rx_msg(m);
    return m;
}

static int rx_msg_free(struct rx_msg_fifo *f)
{
    if (f->head == f->tail)
        return -1; /* empty */
    bzero(&f->q[f->head], sizeof(f->q[0]));
    f->head = (f->head + 1) % RX_MSG_FIFO_SIZE;
    return 0;
}

static uint32_t uint32_from_be(uint8_t *buf)
{
    ASSERT(buf);
    return (uint32_t)buf[0] << 24 | (uint32_t)buf[1] << 16 |
           (uint32_t)buf[2] <<  8 | (uint32_t)buf[3] <<  0;
}

static void uint32_to_be(uint8_t *buf, uint32_t val)
{
    ASSERT(buf);
    buf[0] = val >> 24;
    buf[1] = val >> 16;
    buf[2] = val >>  8;
    buf[3] = val >>  0;
}

static void payload_to_buf(uint8_t *buf, unsigned buf_size,
                           uint64_t *payload, unsigned payload_dwords,
                           unsigned dw_offset, unsigned len)
{
    uint64_t data_dw;
    unsigned p = 0, bytes_in_dw;
    for (unsigned dw = 0; dw < payload_dwords; ++dw) {
        ASSERT(dw < payload_dwords);
        data_dw = payload[dw] >> (dw_offset * 8);
        bytes_in_dw = MIN(len, sizeof(uint64_t));
        for (unsigned b = 0; b < bytes_in_dw; ++b) {
            ASSERT(p < buf_size);
            /* MSB first */
            buf[p++] = data_dw >> ((bytes_in_dw - 1 - b) * 8);
        }
    }
}

static void buf_to_payload(uint64_t *payload, unsigned payload_size_dwords,
                           unsigned *payload_dwords, unsigned dw_offset,
                           uint8_t *buf, unsigned len)
{
    unsigned p = 0, bytes_in_dw;
    *payload_dwords = 0;
    while (p < len) {
        uint64_t data_dw = 0;
        bytes_in_dw = MIN(len, sizeof(uint64_t));
        for (unsigned b = 0; b < bytes_in_dw; ++b) {
            ASSERT(p < len);
            data_dw |= (uint64_t)buf[p++] <<
                ((dw_offset + bytes_in_dw - 1 - b) * 8);
        }
        ASSERT(*payload_dwords < payload_size_dwords);
        payload[(*payload_dwords)++] = data_dw;
    }
}

struct rio_ep *rio_ep_create(const char *name, uintptr_t base,
                             rio_bus_addr_t out_as_base, unsigned out_as_width,
                             enum rio_transport_type ttype,
                             enum rio_addr_width addr_width,
                             rio_bus_addr_t buf_mem_ep, uint8_t *buf_mem_cpu,
                             unsigned buf_mem_size)
{
    unsigned buf_len = 0;
    int num_msg_rx_desc;

    struct rio_ep *ep = OBJECT_ALLOC(rio_eps);
    if (!ep)
        return NULL;
    ep->name = name;
    ep->base = base;
    ep->out_as_base = out_as_base;
    ep->out_as_width = out_as_width;
    ep->ttype = ttype;
    ep->addr_width = addr_width;

    ep->mapped_out_regions = 0;
    ep->mapped_in_addr_spaces = 0;

    /* Used later for translating addresses between CPU and EP */
    ep->buf_mem_ep = buf_mem_ep;
    ep->buf_mem_cpu = buf_mem_cpu;
    ep->buf_mem_size = buf_mem_size;

    /* "Allocate" buffers (create pointers accessible by CPU) */
    /* TODO: align each buffer */

    ep->msg_tx_desc_buf = ep->buf_mem_cpu + buf_len;
    ep->msg_tx_desc_buf_size = MSG_CHAIN_BUF_SIZE;
    buf_len += ep->msg_tx_desc_buf_size;
    if (buf_mem_size < buf_len)
        goto fail_mem;

    ep->msg_rx_desc_buf = (uint8_t (*)[MSG_CHAIN_BUF_SIZE])(ep->buf_mem_cpu + buf_len);
    ep->msg_rx_desc_buf_size = NUM_MSG_RX_CHAINS * MSG_CHAIN_BUF_SIZE;
    buf_len += ep->msg_rx_desc_buf_size;
    if (buf_mem_size < buf_len)
        goto fail_mem;

    for (int i = 0; i < NUM_MSG_RX_CHAINS; ++i) {
        num_msg_rx_desc =
            init_rx_chain(ep, ep->msg_rx_desc_buf[i], sizeof(ep->msg_rx_desc_buf[i]));
        ASSERT(num_msg_rx_desc > 0);
        enqueue_rx_chain(ep, &ep->msg_rx_desc_buf[i][0]);
    }
    ep->rx_chain = 0;
    ep->msg_rx_desc_addr = &ep->msg_rx_desc_buf[ep->rx_chain][0];

    /* Start a "currently received and assembled" message */
    for (int mbox = 0; mbox < NUM_MBOXES; ++mbox) {
        for (int letter = 0; letter < NUM_LETTERS; ++letter) {
            struct rx_msg *msg = rx_msg_alloc(&ep->rx_msgs[mbox][letter]);
            ASSERT(msg); /* must have at least one spot */
        }
    }

    printf("RIO EP %s: created; %u msg rx chains, descs %u per chain\r\n",
           ep->name, NUM_MSG_RX_CHAINS, num_msg_rx_desc);
    return ep;

fail_mem:
    printf("RIO EP %s: ERROR: insufficient buffer memory: %u < %u\r\n",
           ep->name, buf_mem_size, buf_len);
    OBJECT_FREE(ep);
    return NULL;
}

int rio_ep_destroy(struct rio_ep *ep)
{
    ASSERT(ep);
    printf("RIO EP %s: destroy\r\n", ep->name);
    OBJECT_FREE(ep);
    return 0;
}

const char *rio_ep_name(struct rio_ep *ep) {
    ASSERT(ep->name);
    return ep->name;
}

void rio_ep_set_devid(struct rio_ep *ep, rio_devid_t devid)
{
    /* The driver abstracts dev id width from the consumer */
    uint32_t reg = 0;
    reg = FIELD_DP32(reg, B_DEV_ID, BASE_DEVICE_ID, devid) |
        FIELD_DP32(reg, B_DEV_ID, LARGE_BASE_DEVICE_ID, devid);
    RIO_REGB_WRITE32(ep->base, B_DEV_ID, reg);
}

rio_devid_t rio_ep_get_devid(struct rio_ep *ep)
{
    uint32_t reg = RIO_REGB_READ32(ep->base, B_DEV_ID);
    switch (ep->ttype) {
        case RIO_TRANSPORT_DEV8:
            return FIELD_EX32(reg, B_DEV_ID, BASE_DEVICE_ID);
        case RIO_TRANSPORT_DEV16:
            return FIELD_EX32(reg, B_DEV_ID, LARGE_BASE_DEVICE_ID);
        default:
            panic("RIO: unsupported transport type");
    } 
    panic("unreachable");
    return 0;
}

int rio_ep_sp_send(struct rio_ep *ep, struct RioPkt *pkt)
{
    bzero(ep->pkt_buf, sizeof(ep->pkt_buf));
    unsigned pkt_len;
    pkt_len = pack_pkt(ep->pkt_buf, sizeof(ep->pkt_buf), pkt);
    DPRINTF("RIO EP %s: packed packet into %u bytes...\r\n", ep->name, pkt_len);

    DPRINTF("RIO EP %s: waiting for space in FIFO...\r\n", ep->name);
    while (RIO_REGB_READ32(ep->base, IR_SP_TX_STAT) &
                IR_SP_TX_STAT__FULL__MASK) {
        msleep(POLL_INTERVAL_MS);
    }

    if ((RIO_REGB_READ32(ep->base, IR_SP_TX_STAT) &
            IR_SP_TX_STAT__TX_FIFO_STATE__MASK) != SP_TX_FIFO_STATE_IDLE) {
        printf("RIO EP %s: ERROR: SP send: TX FIFO not idle before enqueue\r\n",
               ep->name);
        return 1;
    }

    pkt_len = ALIGN(pkt_len, 2); /* word-granularity */

    RIO_REGB_WRITE32(ep->base, IR_SP_TX_CTRL,
        (pkt_len << IR_SP_TX_CTRL__OCTETS_TO_SEND__SHIFT)
            & IR_SP_TX_CTRL__OCTETS_TO_SEND__MASK);
    for (int i = 0; i < pkt_len; i += 4) {
        uint32_t w = (ep->pkt_buf[i + 0] << 24) |
                     (ep->pkt_buf[i + 1] << 16) |
                     (ep->pkt_buf[i + 2] <<  8) |
                     (ep->pkt_buf[i + 3] <<  0);
        RIO_REGB_WRITE32(ep->base, IR_SP_TX_DATA, w);
    };

    /* Wait just for neatness -- this wait is not required. */
    printf("RIO: SP send: waiting TX FIFO to go idle...\r\n");
    while ((RIO_REGB_READ32(ep->base, IR_SP_TX_STAT) &
                IR_SP_TX_STAT__TX_FIFO_STATE__MASK)
            != SP_TX_FIFO_STATE_IDLE) {
        msleep(POLL_INTERVAL_MS);
    }
    return 0;
}

int rio_ep_sp_recv(struct rio_ep *ep, struct RioPkt *pkt)
{
    bzero(ep->pkt_buf, sizeof(ep->pkt_buf));

    DPRINTF("RIO EP %s: waiting for packet in RX FIFO...\r\n", ep->name);
    while ((RIO_REGB_READ32(ep->base, IR_SP_RX_STAT) &
                IR_SP_RX_STAT__BUFFERS_FILLED__MASK) == 0) {
        msleep(POLL_INTERVAL_MS);
    }

    if ((RIO_REGB_READ32(ep->base, IR_SP_RX_STAT) & IR_SP_RX_STAT__RX_FIFO_STATE__MASK)
            != SP_RX_FIFO_STATE_IDLE) {
        printf("RIO: ERROR: SP recv: RX FIFO not idle before dequeue\r\n");
        return 1;
    }
    
    unsigned len = 0;

    do { /* need to do first read for octets remaining to be initialized */
        uint32_t w = RIO_REGB_READ32(ep->base, IR_SP_RX_DATA);
        for (int i = 0; i < sizeof(uint32_t); ++i) {
            ep->pkt_buf[len++] = (w & 0xff000000) >> 24;
            w <<= 8;
        }
    } while ((RIO_REGB_READ32(ep->base, IR_SP_RX_STAT) &
         IR_SP_RX_STAT__OCTETS_REMAINING__MASK) > 0);

    /* Wait just for neatness -- this wait is not required. */
    printf("RIO: SP recv: waiting for RX FIFO to go idle\r\n");
    while ((RIO_REGB_READ32(ep->base, IR_SP_RX_STAT) &
                           IR_SP_RX_STAT__RX_FIFO_STATE__MASK)
                != SP_RX_FIFO_STATE_IDLE) {
        msleep(POLL_INTERVAL_MS);
    }

    return unpack_pkt(pkt, ep->pkt_buf, len);
}

static int rio_ep_access_csr(struct rio_ep *ep, uint8_t *data, uint16_t len,
                             rio_dest_t dest, uint32_t addr,
                             enum access_type access)
{
    int rc;
    enum rio_transaction resp_transaction;
    unsigned resp_payload_len, dw_offset;

    ep->out_pkt.ttype = ep->ttype;
    ep->out_pkt.src_id = rio_ep_get_devid(ep);
    ep->out_pkt.dest_id = dest.devid;
    ep->out_pkt.hop_count = dest.hops;

    ep->out_pkt.ftype = RIO_FTYPE_MAINT;
    ep->out_pkt.src_tid = TID_SW;

    ep->out_pkt.dw_addr = BYTE_ADDR_TO_DW_ADDR(addr);
    ep->out_pkt.dw_offset = dw_offset = addr & 0b111;
    ep->out_pkt.rdwr_bytes = len;

    switch (access) {
        case ACCESS_READ:
            ep->out_pkt.transaction = RIO_TRANS_MAINT_REQ_READ;
            ep->out_pkt.payload_len = 0;
            resp_transaction = RIO_TRANS_MAINT_RESP_READ;
            resp_payload_len = div_ceil(len, sizeof(uint64_t));
            break;
        case ACCESS_WRITE:
            ep->out_pkt.transaction = RIO_TRANS_MAINT_REQ_WRITE;
            resp_transaction = RIO_TRANS_MAINT_RESP_WRITE;
            resp_payload_len = 0;
            buf_to_payload(ep->out_pkt.payload, sizeof(ep->out_pkt.payload),
                           &ep->out_pkt.payload_len, dw_offset, data, len);
            break;
    }

    printf("RIO EP %s: sending maint req:\r\n", ep->name);
    rio_print_pkt(&ep->out_pkt);

	rc = rio_ep_sp_send(ep, &ep->out_pkt);
	if (rc)
		return rc;

    rc = rio_ep_sp_recv(ep, &ep->in_pkt);
	if (rc)
		return rc;

    printf("RIO EP %s: received maint resp:\r\n", ep->name);
    rio_print_pkt(&ep->in_pkt);

    if (!(ep->in_pkt.ftype == RIO_FTYPE_MAINT &&
          ep->in_pkt.transaction == resp_transaction &&
          ep->in_pkt.target_tid == ep->out_pkt.src_tid &&
          ep->in_pkt.payload_len == resp_payload_len)) {
        printf("RIO EP %s: ERROR: bad response to MAINTENANCE request\r\n", ep->name);
		return 1;
    }

    if (ep->in_pkt.status != RIO_STATUS_DONE) {
        printf("RIO EP %s: ERROR: MAINTENANCE request failed with status %u\r\n",
               ep->name, ep->in_pkt.status);
        return 1;
    }

    if (access == ACCESS_READ) {
        payload_to_buf(data, len, ep->in_pkt.payload, ep->in_pkt.payload_len,
                       dw_offset, len);
    }
	return 0;
}

int rio_ep_read_csr(struct rio_ep *ep, uint8_t *data, unsigned len,
                    rio_dest_t dest, uint32_t addr)
{
    return rio_ep_access_csr(ep, data, len, dest, addr, ACCESS_READ);
}

int rio_ep_write_csr(struct rio_ep *ep, const uint8_t *data, unsigned len,
                     rio_dest_t dest, uint32_t addr)
{
    return rio_ep_access_csr(ep, (uint8_t *)data, len, dest, addr,
                             ACCESS_WRITE);
}

int rio_ep_read_csr32(struct rio_ep *ep, uint32_t *data, rio_dest_t dest,
                       uint32_t addr)
{
    ASSERT(ALIGNED(addr, 2));
    uint8_t bytes[sizeof(uint32_t)];
    int rc = rio_ep_read_csr(ep, bytes, sizeof(uint32_t), dest, addr);
    if (rc)
        return rc;
    *data = uint32_from_be(bytes);
    return 0;
}

int rio_ep_write_csr32(struct rio_ep *ep, const uint32_t data,
                        rio_dest_t dest, uint32_t addr)
{
    ASSERT(ALIGNED(addr, 2));
    uint8_t bytes[sizeof(uint32_t)];
    uint32_to_be(bytes, data);
    return rio_ep_write_csr(ep, bytes, sizeof(uint32_t), dest, addr);
}

int rio_ep_msg_send(struct rio_ep *ep, rio_devid_t dest, uint64_t launch_time,
                    uint8_t mbox, uint8_t letter, uint8_t seg_size,
                    uint8_t *payload, unsigned len)
{
    if (msg_seg_size_field(seg_size) == MSG_SEG_FIELD_INVALID) {
        printf("RIO EP %s: ERROR: invalid msg segment size: %u"
               " (must be power of 2 <= 256)\r\n", ep->name, seg_size);
        return 1;
    }

    uint8_t msg_len = div_ceil(len, seg_size);
    if (msg_len > MAX_MSGSEG_XMBOXMENTS) {
        printf("RIO EP %s: ERROR: msg of length %u with segment size %u"
               " has too many segments: %u (>= %u)\r\n",
               ep->name, len, seg_size, MAX_MSGSEG_XMBOXMENTS);
        return 1;
    }

    if (msg_len > 0 && mbox >= 4) {
        printf("RIO EP %s: ERROR: invalid mailbox for multi-segment message: %u"
               " (>= 4)\r\n", ep->name);
        return 2;
    } else if (msg_len == 0 && mbox >= 64) {
        printf("RIO EP %s: ERROR: invalid mailbox for single-segment message: %u"
               " (>= 64)\r\n", ep->name, mbox);
        return 3;
    }

    if (letter > 4) {
        printf("RIO EP %s: ERROR: invalid letter index for mailbox: %u"
               " (>= 4)\r\n", ep->name, letter);
        return 4;
    }

    MsgDescType desc_type = MSG_DESC_INITIATOR_PS;

    uint8_t *desc_addr = &ep->msg_tx_desc_buf[0];
    uint8_t *payload_addr = desc_addr + MAX_MSG_DESC_SIZE;
    uint8_t *payload_ptr = payload;

    for (int seg = 0; seg < msg_len; ++seg) {

        uint8_t *next_desc_addr = desc_addr + MAX_MSG_DESC_SIZE + MAX_MSGSEG_XMBOX_SIZE;

        MsgDesc desc = { /* fields validated later in pack() */
            .type = desc_type,
            .free = 0,
            .interrupt = false, /* TODO */

            .ttype = ep->ttype,
            .dev_id.dest_id = dest,

            .mbox = mbox,
            .letter = letter,

            .seg_size = seg_size,

            .msg_len = msg_len,
            .msg_seg = seg,

            .payload_ptr = payload_addr,
            .next_desc_addr = (seg == msg_len - 1) ? 0 : next_desc_addr,
        };

        vmem_cpy(payload_addr, payload_ptr, seg_size);
        payload_ptr += seg_size;

        printf("RIO EP %s: created msg descriptor %u/%u at %p:\r\n",
               ep->name, seg + 1, msg_len, desc_addr);
        print_msg_desc(&desc);

        pack_msg_desc(ep, desc_addr, MAX_MSG_DESC_SIZE, &desc);

        if (seg < msg_len - 1) /* don't overwrite on last iteration */
            desc_addr = next_desc_addr;
    }

    rio_bus_addr_t desc_chain_addr_ep = cpu_to_ep_addr(ep, &ep->msg_tx_desc_buf[0]);

    switch (desc_type) {
        case MSG_DESC_INITIATOR_PS:
            RIO_REGB_WRITE32(ep->base, IR_MSG_INIT_PS_DESCR_FIFO_H,
                         (uint32_t)((uint64_t)desc_chain_addr_ep >> 32));
            RIO_REGB_WRITE32(ep->base, IR_MSG_INIT_PS_DESCR_FIFO_L,
                         (uint32_t)((uint64_t)desc_chain_addr_ep & 0xffffffff));
            break;
        case MSG_DESC_INITIATOR_DS:
            RIO_REGB_WRITE32(ep->base, IR_MSG_INIT_DS_DESCR_FIFO_H,
                         (uint32_t)((uint64_t)desc_chain_addr_ep >> 32));
            RIO_REGB_WRITE32(ep->base, IR_MSG_INIT_DS_DESCR_FIFO_L,
                         (uint32_t)((uint64_t)desc_chain_addr_ep & 0xffffffff));
            break;
        default:
            ASSERT(!"unexpected msg descriptor type");
    }

    /* TODO: wait for interrupt */
    printf("RIO EP %s: waiting for last msg desc to be released...\r\n", ep->name);
    bool free = false;
    do {
        unsigned pos = 0;
        uint64_t hdr = msg_desc_read_dw(desc_addr, MAX_MSG_DESC_SIZE, &pos);
        free = FIELD_EX64(hdr, MSG_DESC, FREE);
        if (!free)
            msleep(POLL_INTERVAL_MS);
    } while (!free);
    printf("RIO EP %s: msg sent\r\n", ep->name);

    return 0;
}

static void receive_msg_segment(struct rio_ep *ep)
{
    uint8_t free;
    MsgDesc desc;
    enum rio_status status;
    int rc;

    ASSERT(ep->msg_rx_desc_addr);

    /* TODO: wait for interrupt */
    printf("RIO EP %s: waiting for segment...\r\n", ep->name);
    do { /* wait for the next segment */
        unsigned pos = 0;
        uint64_t hdr = msg_desc_read_dw(ep->msg_rx_desc_addr, MAX_MSG_DESC_SIZE, &pos);
        free = FIELD_EX64(hdr, MSG_DESC, FREE);
        if (!free)
            msleep(POLL_INTERVAL_MS);
    } while (!free);
    rc = unpack_msg_desc(ep, &desc, ep->msg_rx_desc_addr, MAX_MSG_DESC_SIZE,
                         MSG_DESC_TARGET);
    ASSERT(!rc && "invalid RIO msg descriptor"); /* TODO: propagate */

    printf("RIO EP %s: got segment:", ep->name);
    print_msg_desc(&desc);

    ASSERT(desc.mbox < NUM_MBOXES);
    ASSERT(desc.letter < NUM_LETTERS);
    struct rx_msg *msg = rx_msg_peek(&ep->rx_msgs[desc.mbox][desc.letter]);
    ASSERT(msg); /* FIFO is can't be empty, is replenished internally */

    status = RIO_STATUS_DONE;

    printf("RIO EP %s: msg segments bitmask (pre): 0x%x\r\n", ep->name, msg->segments);
    if (msg->segments == ~0) { /* starting fresh message (first segment) */
        msg->len = desc.msg_len * desc.seg_size;
        msg->segments = (1 << desc.msg_len) - 1;
        msg->rcv_time = 0;
    } else if (msg->segments & (1 << desc.msg_seg)) {
        /* This segment already marked received, so assuming that this new
           segment belongs to the next message. This is fatal because we
           don't support more than one message in flight (i.e. previous
           message is incomplete, when the next one is already arriving). */
        printf("RIO EP %s: ERROR: more than 1 in-flight message\r\n",
                ep->name);
        status = RIO_STATUS_ERROR;
    }

    if (status != RIO_STATUS_ERROR) {
        vmem_cpy(msg->payload + desc.msg_seg * desc.seg_size,
                 desc.payload_ptr, desc.seg_size);
        msg->rcv_time = desc.timestamp.rcv_time; /* keep time of latest segment */
        msg->src_id = desc.dev_id.src_id;
        msg->segments &= ~(1 << desc.msg_seg);
        printf("RIO EP %s: msg segments bitmask (post): 0x%x\r\n",
               ep->name, msg->segments);
    }

    if (!desc.next_desc_addr) { /* chain still has unused buffers */
        ep->msg_rx_desc_addr = (uint8_t *)desc.next_desc_addr;
    } else { /* all buffers in the chain have been used */

        printf("RIO EP %s: chain %u used up, reenqeueuing\r\n",
               ep->name, ep->rx_chain);

        uint8_t *head_desc = &ep->msg_rx_desc_buf[ep->rx_chain][0];
        reserve_rx_chain(ep, head_desc, sizeof(ep->msg_rx_desc_buf[0]));
        enqueue_rx_chain(ep, head_desc);

        ep->rx_chain = (ep->rx_chain + 1) % NUM_MSG_RX_CHAINS;
        ep->msg_rx_desc_addr = &ep->msg_rx_desc_buf[ep->rx_chain][0];
    }

    if (msg->segments == 0) { /* all segments received */
        printf("RIO EP %s: msg for mbox:letter %u:%u completed\r\n", ep->name,
               desc.mbox, desc.letter);
        msg = rx_msg_alloc(&ep->rx_msgs[desc.mbox][desc.letter]);
        /* not easily recoverable: consumers may be peeking at the oldest
           message, so we can't drop it. What might be implementable is to
           drop the new (just completed) message instead of oldest. */
        ASSERT(msg && "RIO RX MSG FIFO overflow");
    }
}

int rio_ep_msg_recv(struct rio_ep *ep, uint8_t mbox, uint8_t letter,
                    rio_devid_t *src, uint64_t *rcv_time,
                    uint8_t *payload, unsigned *len)
{
    if (mbox >= NUM_MBOXES || letter >= NUM_LETTERS) {
        printf("RIO EP %s: ERROR: invalid mailbox/letter index: %u/%u "
               "(total available %u/%u)\r\n",
                ep->name, mbox, letter, NUM_MBOXES, NUM_LETTERS);
        return 1;
    }
    struct rx_msg *msg = rx_msg_peek(&ep->rx_msgs[mbox][letter]);
    ASSERT(msg); /* FIFO can't be empty, replenished internally */
    while (msg->segments) { /* while msg not complete */
        receive_msg_segment(ep);
    }
    ASSERT(*len >= msg->len);
    *len = msg->len;
    *src = msg->src_id;
    *rcv_time = msg->rcv_time;
    vmem_cpy(payload, msg->payload, msg->len);
    rx_msg_free(&ep->rx_msgs[mbox][letter]);
    return 0;
}

int rio_ep_doorbell_send_async(struct rio_ep *ep, rio_devid_t dest, uint16_t info)
{
    ep->out_pkt.ttype = ep->ttype;
    ep->out_pkt.src_id = rio_ep_get_devid(ep);
    ep->out_pkt.dest_id = dest;

    ep->out_pkt.ftype = RIO_FTYPE_DOORBELL;
    ep->out_pkt.src_tid = TID_SW;

    ep->out_pkt.info = info;

    printf("RIO EP %s: sending doorbell req:\r\n", ep->name);
    rio_print_pkt(&ep->out_pkt);

	return rio_ep_sp_send(ep, &ep->out_pkt);
}

int rio_ep_doorbell_reap(struct rio_ep *ep, enum rio_status *status)
{
    int rc;

    rc = rio_ep_sp_recv(ep, &ep->in_pkt);
	if (rc)
		return rc;

    printf("RIO EP %s: received resp:\r\n", ep->name);
    rio_print_pkt(&ep->in_pkt);

    if (!(ep->in_pkt.ftype == RIO_FTYPE_RESP &&
          ep->in_pkt.transaction == RIO_TRANS_RESP_WITHOUT_PAYLOAD &&
          ep->in_pkt.target_tid == ep->out_pkt.src_tid &&
          ep->in_pkt.payload_len == 0)) {
        printf("RIO EP %s: ERROR: bad response to DOORBELL request\r\n", ep->name);
		return 1;
    }

    *status = ep->in_pkt.status;
    return 0;
}

int rio_ep_doorbell_recv(struct rio_ep *ep, uint16_t *info)
{
    int rc;

    rc = rio_ep_sp_recv(ep, &ep->in_pkt);
	if (rc)
		return rc;

    if (ep->in_pkt.ftype != RIO_FTYPE_DOORBELL) {
        printf("RIO EP %s: ERROR: unexpected packet: ftype %u != %u\r\n",
               ep->name, ep->in_pkt.ftype);
        return 1;
    }

    *info = ep->in_pkt.info;

    ep->out_pkt.ftype = RIO_FTYPE_RESP;
    ep->out_pkt.transaction = RIO_TRANS_RESP_WITHOUT_PAYLOAD;
    ep->out_pkt.status = RIO_STATUS_DONE;
    ep->out_pkt.target_tid = ep->in_pkt.src_tid;

    return rio_ep_sp_send(ep, &ep->out_pkt);
}

int rio_ep_map_in(struct rio_ep *ep, unsigned num_addr_spaces,
                  struct rio_map_in_as_cfg *cfgs)
{
    if (num_addr_spaces > RIO_NUM_IN_ADDR_SPACES || !is_pow2(num_addr_spaces)) {
        printf("RIO EP %s: ERROR: invalid number of map regions: %u "
               "(must be power of 2 up to %u)\r\n", ep->name,
               num_addr_spaces, RIO_NUM_IN_ADDR_SPACES);
        return 1;
    }

    uint32_t imap_ctrl = FIELD_DP32(0, IR_IMAP_CTRL, SUBREGIONS,
                                    log2_of_pow2(num_addr_spaces));
    RIO_REGB_WRITE32(ep->base, IR_IMAP_CTRL, imap_ctrl);

    for (int as = 0; as < num_addr_spaces; ++as) {

        struct rio_map_in_as_cfg *cfg = &cfgs[as];

        /* The address (into target address space on the remote side) is formed from
           the join of the within-address-space offset bits and the subset of
           the bits in the bus address parameter in the passed AS config. So, in
           the address register for the incoming AS config that we are about to
           write, the bits of the AS address that are within the AS are not used,
           and thus should not be set -- that's the alignment requirement. */
        if (!ALIGNED64(cfg->bus_addr, cfg->addr_width)) {
            printf("RIO EP %s: ERROR: unaligned address space address: "
                   "0x%08x%08x (must be aligned to asion size: %u bits)\r\n",
                   ep->name,
                   (uint32_t)(cfg->bus_addr >> 32), (uint32_t)cfg->bus_addr,
                   cfg->addr_width);
            return 2; 
        }

        printf("RIO EP %s: IN asion %u of size %u bits "
               "for src %x & %x -> %08x%08x\r\n",
               ep->name, as, cfg->addr_width, cfg->src_id, cfg->src_id_mask,
               (uint32_t)(cfg->bus_addr >> 32),
               (uint32_t)(cfg->bus_addr & 0xffffffff));
        
        uint32_t ime_ctrl = FIELD_DP32(0, IR_IME_0_CTRL, ADDR_SIZE, 
                                       rio_addr_width_to_field(cfg->addr_width));
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_CTRL, as, ime_ctrl);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_SRCID, as, cfg->src_id);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_SRCIDM, as, cfg->src_id_mask);

        ASSERT(ALIGNED64(cfg->bus_addr, cfg->addr_width));
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_ADDR_H, as, cfg->bus_addr >> 32);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_ADDR_L, as, cfg->bus_addr);
    }
    ep->mapped_in_addr_spaces = num_addr_spaces;
    return 0;
}

/* support unmapping only all at once, for symmetry to mapping */
void rio_ep_unmap_in(struct rio_ep *ep)
{
    for (int as = 0; as < ep->mapped_in_addr_spaces; ++as) {
        /* There's no disable switch, so just reset everything to zero */
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_SRCIDM, as, 0);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_SRCID, as, 0);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_CTRL, as, 0);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_ADDR_H, as, 0);
        RIO_REGBO_WRITE32(ep->base, IR_IME_0_ADDR_L, as, 0);
    }
}

int rio_ep_map_out(struct rio_ep *ep, unsigned num_regions,
                   struct rio_map_out_region_cfg *cfgs)
{
    if (num_regions > RIO_NUM_OUT_REGIONS || !is_pow2(num_regions)) {
        printf("RIO EP %s: ERROR: invalid number of map regions: %u "
               "(must be power of 2 up to %u)\r\n", ep->name,
               num_regions, RIO_NUM_OUT_REGIONS);
        return 1;
    }

    uint32_t omap_ctrl = FIELD_DP32(0, IR_OMAP_CTRL, SUBREGIONS,
                                    log2_of_pow2(num_regions));
    RIO_REGB_WRITE32(ep->base, IR_OMAP_CTRL, omap_ctrl);

    /* Used for aligmnet checks and log output only */
    unsigned out_region_size_bits = ep->out_as_width - log2_of_pow2(num_regions);

    for (int reg = 0; reg < num_regions; ++reg) {

        struct rio_map_out_region_cfg *cfg = &cfgs[reg];

        printf("RIO EP %s: OUT region %u of size %u bits "
               "-> dest %x @ %02x%08x%08x\r\n", ep->name, reg,
               out_region_size_bits, cfg->dest_id, cfg->rio_addr.hi,
               (uint32_t)(cfg->rio_addr.lo >> 32), (uint32_t)cfg->rio_addr.lo);

        /* TODO: clarify xamsbs: why is it drawn on the right in User Guide Figure 5
         * when the spec says these are *most* significant bits, not LSBs? */

        /* Refer to Figure 5 of User Guide, RIO byte address is:
         *    xamsbs[2] | extaddr[0or16or32] | dwaddr[29] | wdptr[1] | [2] */
        ASSERT(IR_OME_0_CTRL__XAMSBS__LENGTH == 2);
        uint8_t xamsbs;
        uint32_t extaddr, dwaddr;
        switch (cfg->addr_width) {
            case RIO_ADDR_WIDTH_34_BIT:
                xamsbs = cfg->rio_addr.lo >> 32;
                extaddr = 0;
                dwaddr = cfg->rio_addr.lo & 0xffffffff;
                break;
            case RIO_ADDR_WIDTH_50_BIT:
                xamsbs = cfg->rio_addr.lo >> 48;
                extaddr = (cfg->rio_addr.lo >> 32) & 0xffff; /* exclude xamsbs */
                dwaddr = cfg->rio_addr.lo & 0xffffffff;
                break;
            case RIO_ADDR_WIDTH_66_BIT:
                xamsbs = cfg->rio_addr.hi;
                extaddr = cfg->rio_addr.lo >> 32; /* exl xamsbs (not in .lo) */
                dwaddr = cfg->rio_addr.lo & 0xffffffff;
                break;
        }

        if ((xamsbs & ~0x3) != 0) {
            printf("RIO EP %s: ERROR: region RIO address too long: "
                   "xamsbs 0x%x (must be 2 bits)\r\n", xamsbs);
            return 1;
        }

        /* not all bits of dwaddr are going to used, depending on num regions */
        if (!ALIGNED(dwaddr, out_region_size_bits)) {
            printf("RIO EP %s: ERROR: region RIO address not aligned: "
                   "dwaddr 0x%08x (must be aligned to region size: %u bits)\r\n",
                   ep->name, dwaddr, out_region_size_bits);
            return 2; 
        }

        uint32_t ctrl = 0;
        /* TODO: expose the other types */
        ctrl = FIELD_DP32(ctrl, IR_OME_0_CTRL, WRITE_TYPE, MAP_NWRITE);
        ctrl = FIELD_DP32(ctrl, IR_OME_0_CTRL, PRIO, 0);
        ctrl = FIELD_DP32(ctrl, IR_OME_0_CTRL, TTYPE, cfg->ttype);
        ctrl = FIELD_DP32(ctrl, IR_OME_0_CTRL, ADDR_SIZE,
                          rio_addr_width_to_field(cfg->addr_width));
        ctrl = FIELD_DP32(ctrl, IR_OME_0_CTRL, XAMSBS, xamsbs);
        RIO_REGBO_WRITE32(ep->base, IR_OME_0_CTRL, reg, ctrl);
        RIO_REGBO_WRITE32(ep->base, IR_OME_0_DESTID, reg, cfg->dest_id);

        RIO_REGBO_WRITE32(ep->base, IR_OME_0_ADDR_H, reg, extaddr);
        RIO_REGBO_WRITE32(ep->base, IR_OME_0_ADDR_L, reg, dwaddr);
    }
    ep->mapped_out_regions = num_regions;
    return 0;
}

/* support unmapping only all at once, for symmetry to mapping */
void rio_ep_unmap_out(struct rio_ep *ep)
{
    for (int reg = 0; reg < ep->mapped_out_regions; ++reg) {
        uint32_t ctrl = 0;
        ctrl = FIELD_DP32(ctrl, IR_OME_0_CTRL, WRITE_TYPE, MAP_DISABLED);
        RIO_REGBO_WRITE32(ep->base, IR_OME_0_CTRL, reg, ctrl);

        RIO_REGBO_WRITE32(ep->base, IR_OME_0_DESTID, reg, 0);
        RIO_REGBO_WRITE32(ep->base, IR_OME_0_ADDR_H, reg, 0);
        RIO_REGBO_WRITE32(ep->base, IR_OME_0_ADDR_L, reg, 0);

        RIO_REGB_WRITE32(ep->base, IR_OMAP_CTRL, 0);
    }
}

uint64_t rio_ep_get_outgoing_base(struct rio_ep *ep, unsigned num_regions,
                                  unsigned region)
{
    int region_size_bits = ep->out_as_width - log2_of_pow2(num_regions);
    unsigned region_size = 1ULL << region_size_bits;
    return ep->out_as_base + region * region_size;
}
uint64_t rio_ep_get_outgoing_size_bits(struct rio_ep *ep, unsigned num_regions)
{
    return ep->out_as_width - log2_of_pow2(num_regions);
}

rio_addr_t rio_ep_get_cfg_base(struct rio_ep *ep)
{
    uint64_t dw_addr = ((uint64_t)RIO_REGB_READ32(ep->base, LCS_BA0) << 32) |
                        RIO_REGB_READ32(ep->base, LCS_BA1);
    return rio_addr_from_dw_addr(dw_addr);
}

void rio_ep_set_cfg_base(struct rio_ep *ep, rio_addr_t addr)
{
    uint64_t dw_addr = rio_addr_to_dw_addr(addr);
    RIO_REGB_WRITE32(ep->base, LCS_BA0, dw_addr >> 32);
    RIO_REGB_WRITE32(ep->base, LCS_BA1, (uint32_t)dw_addr);
}

int rio_ep_read(struct rio_ep *ep, uint8_t *data, unsigned len,
                rio_addr_t addr, rio_devid_t dest)
{
	int rc;
    unsigned dw_offset;

    bzero(&ep->out_pkt, sizeof(ep->out_pkt));

    ep->out_pkt.addr_width = ep->addr_width;
    ep->out_pkt.ttype = ep->ttype;

    ep->out_pkt.src_id = rio_ep_get_devid(ep);
    ep->out_pkt.dest_id = dest;

    ep->out_pkt.ftype = RIO_FTYPE_READ;
    ep->out_pkt.src_tid = TID_SW;
    ep->out_pkt.transaction = RIO_TRANS_READ_NREAD;
    ep->out_pkt.dw_addr = rio_addr_to_dw_addr(addr);
    ep->out_pkt.dw_offset = dw_offset = addr.lo % sizeof(uint64_t);
    ep->out_pkt.rdwr_bytes = len;
    ep->out_pkt.payload_len = 0;

    ASSERT(ep->out_pkt.rdwr_bytes % sizeof(uint64_t) == 0 ||
           ep->out_pkt.rdwr_bytes < sizeof(uint64_t));

    printf("RIO: read: sending pkt on EP 0:\r\n");
    rio_print_pkt(&ep->out_pkt);

	rc = rio_ep_sp_send(ep, &ep->out_pkt);
	if (rc)
		return rc;

    rc = rio_ep_sp_recv(ep, &ep->in_pkt);
	if (rc)
		return rc;

    printf("RIO: read: received pkt on EP 0:\r\n");
    rio_print_pkt(&ep->in_pkt);

    if (!(ep->in_pkt.ftype == RIO_FTYPE_RESP &&
          ep->in_pkt.transaction == RIO_TRANS_RESP_WITH_PAYLOAD &&
          ep->in_pkt.target_tid == ep->out_pkt.src_tid &&
          ep->in_pkt.payload_len == div_ceil(len, sizeof(uint64_t)))) {
        printf("RIO: ERROR: read: unexpected fields in response pkt\r\n");
        return 1;
    }
    payload_to_buf(data, len, ep->in_pkt.payload, ep->in_pkt.payload_len,
                   dw_offset, len);
	return 0;
}

int rio_ep_write(struct rio_ep *ep, uint8_t *data, unsigned len,
                 rio_addr_t addr, rio_devid_t dest)
{
	int rc;
    unsigned dw_offset;

    bzero(&ep->out_pkt, sizeof(ep->out_pkt));

    ep->out_pkt.addr_width = ep->addr_width;
    ep->out_pkt.ttype = ep->ttype;
    ep->out_pkt.src_id = rio_ep_get_devid(ep);
    ep->out_pkt.dest_id = dest;

    ep->out_pkt.ftype = RIO_FTYPE_WRITE;
    ep->out_pkt.src_tid = TID_SW;
    ep->out_pkt.transaction = RIO_TRANS_WRITE_NWRITE_R;
    ep->out_pkt.dw_addr = rio_addr_to_dw_addr(addr);
    ep->out_pkt.dw_offset = dw_offset = addr.lo % sizeof(uint64_t);
    ep->out_pkt.rdwr_bytes = len;

    buf_to_payload(ep->out_pkt.payload, sizeof(ep->out_pkt.payload),
                   &ep->out_pkt.payload_len, dw_offset, data, len);

    ASSERT(ep->out_pkt.rdwr_bytes % sizeof(uint64_t) == 0 ||
           ep->out_pkt.rdwr_bytes < sizeof(uint64_t));

    printf("RIO: write: sending pkt on EP 0:\r\n");
    rio_print_pkt(&ep->out_pkt);

	rc = rio_ep_sp_send(ep, &ep->out_pkt);
	if (rc)
		return rc;

    rc = rio_ep_sp_recv(ep, &ep->in_pkt);
	if (rc)
		return rc;

    printf("RIO: write: received pkt on EP 0:\r\n");
    rio_print_pkt(&ep->in_pkt);

    if (!(ep->in_pkt.ftype == RIO_FTYPE_RESP &&
          ep->in_pkt.transaction == RIO_TRANS_RESP_WITHOUT_PAYLOAD &&
          ep->in_pkt.target_tid == ep->out_pkt.src_tid &&
          ep->in_pkt.payload_len == 0)) {
        printf("RIO: ERROR: write: unexpected fields in response pkt\r\n");
        return 1;
    }
	return 0;
}

int rio_ep_read32(struct rio_ep *ep, uint32_t *data,
                  rio_addr_t addr, rio_devid_t dest)
{
    uint8_t bytes[sizeof(uint32_t)];
    int rc = rio_ep_read(ep, bytes, sizeof(bytes), addr, dest);
    if (rc)
        return rc;
    *data = uint32_from_be(bytes);
    return rc;
}

int rio_ep_write32(struct rio_ep *ep, uint32_t data,
                   rio_addr_t addr, rio_devid_t dest)
{
    uint8_t bytes[sizeof(uint32_t)];
    uint32_to_be(bytes, data);
    return rio_ep_write(ep, bytes, sizeof(bytes), addr, dest);
}
