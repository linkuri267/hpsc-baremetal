#!/usr/bin/python

import argparse

def int_str_map(s):
    d = {}
    for p in s.split(','):
       if ':' in p: # explicitly named C ISR
           kv = p.split(':')
           d[int(kv[0])] = kv[1]
       else: # create an ISR stub
           if '-' in p:
               r = map(int, p.split('-'))
               irq_nums = range(r[0], r[1])
           else:
               irq_nums = [int(p)]
           for n in irq_nums:
               d[n] = None
    return d

parser = argparse.ArgumentParser(
    description="Generate assembly source for vector table")
parser.add_argument('--internal-irqs', type=int, default=16,
    help='Number internal IRQs')
parser.add_argument('--external-irqs', type=int, default=240,
   help='Number external IRQs')
parser.add_argument('--handlers', type=int_str_map,
    help='IRQ to ISR handler map (syntax: "irq[:isr_name]|irq|irq_from-irq_to,...", if isr_name is omitted, default stub is created)')
parser.add_argument('out_asm',
    help='Output file with generated C source')
parser.add_argument('out_c',
    help='Output file with generated assembly source')
args = parser.parse_args()

if args.handlers is None:
        args.handlers = range(0, 240)

def external(irq):
	return irq - args.internal_irqs

def is_internal(irq):
        return irq < 16;

NVIC_BASE = 0xe000e000
NVIC_ICPR = 0x280

# ISR handlers for each vector number
# The rest of the vectors (not in this dict) get default handler
DEFAULT_ISR = "hang"
isr = {
 0: None,
 1: "reset",
11: "svc",
}

f = open(args.out_asm, "w")

f.write(
"""/* This file was automatically generated by genisr.py. */

.cpu cortex-m4
.thumb

.thumb_func
.global _start
_start:
stacktop: .word 0x20004000
"""
)

for i in range(0, args.internal_irqs + args.external_irqs):
    handler = None
    if i in isr:
        if isr[i] is not None:
            handler = isr[i]
    elif external(i) in args.handlers:
	handler = "isr%u" % external(i)
    elif is_internal(i):
	handler = "exc%u" % i
    else:
        handler = DEFAULT_ISR

    if handler is not None:
        f.write(".word %s\n" % handler)

f.write("\n")

f.write(
"""
.thumb_func
reset:
    bl notmain
    b hang
    b hang

.thumb_func
svc:
    mov r0, #0
    sub r0, #7 // 0xfffffff9: priveledged Thread mode with main stack
    bx r0

.thumb_func
hang:   b .
    b hang
"""
+ "\n");

for irq in range(args.internal_irqs):
    if not irq in isr:
      f.write(("""
.thumb_func
exc%u:
    b exc%u
""") % (irq, irq))

for irq in args.handlers:
    nvic_icpr_addr = NVIC_BASE + NVIC_ICPR + (irq / 32) * 4
    nvic_icpr_val = 1 << (irq % 32)
    if args.handlers[irq] is not None:
	isr = args.handlers[irq]
    else:
	isr = "c_isr%u" % irq

    f.write(("""
.thumb_func
isr%u:
    push {r0, r1, lr}

    bl %s

    /* Clear Pending flag */
    ldrh r0, isr%u_icpr_addr
    mov r1, #%u
    strh r1, [r0]

    pop {r0, r1, pc}

    .align 2
isr%u_icpr_addr:
    .word 0x%08x
""") % (irq, isr, irq, nvic_icpr_val, irq, nvic_icpr_addr))

# Generate C source for stub IRQ handlers (ISRs)

f = open(args.out_c, "w")

f.write(
"""
/* This file was automatically generated by genisr.py.
 *
 * The following define stub functions that are called by the IRQ handlers
 * defined in assembly in vectors.s (generated by genvec.py).
 */
""")

f.write(
"""
#include "printf.h"
""")

# Create stub ISRs for IRQs for which no ISR func was named
for irq in args.handlers:
    if args.handlers[irq] is None:
        f.write(
"""
int c_isr%u (void) {
    static unsigned num_invoc = 0;
    void *p = 0x0;
    asm ("mov %%0, lr\\n" : "=r" (p));
    printf("IRQ %u (%%lu): LR %%p\\r\\n", num_invoc, p);
    num_invoc++;
    return(0);
}
""" % (irq, irq))
